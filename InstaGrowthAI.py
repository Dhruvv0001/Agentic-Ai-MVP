# -*- coding: utf-8 -*-
"""InstaGrowthAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oank_aE2iAt6mK44RLtKFCTU0EVqFAWW

InstaGrowth AI Agent
"""

# ==============================================================================
#  InstaGrowth AI – 4-Agent System  (10 CAP/IDEA/SCH per niche → 10×3×10 = 300)
# ==============================================================================
import subprocess, sys, os, json, re, random, asyncio, gradio as gr, nest_asyncio, time, tempfile, zipfile
from datetime import datetime, timedelta
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import List, Optional, Dict

for pkg in ["aiohttp", "beautifulsoup4", "nest_asyncio"]:
    try: __import__(pkg)
    except: subprocess.check_call([sys.executable, "-m", "pip", "-q", "install", pkg])
import aiohttp
nest_asyncio.apply()

# ------------------  CONFIG  --------------------------------------------------
GEMINI_API_KEY = "AIzaSyDu61_VRLto6Y_n7R4SGcjGg_5oUQFhMo4"   # <-- CHANGE
SERPER_API_KEY = "f3ea8d71be452ba200d0cb5969ec59568a51b7b5"   # <-- CHANGE
OUTPUT_DIR = Path("instagrowth_ai_data")
OUTPUT_DIR.mkdir(exist_ok=True)

# ------------------  DATA MODELS  ---------------------------------------------
@dataclass
class Hashtag:
    tag: str; posts: str; relevance: float; competition: str; source: str

@dataclass
class ContentIdea:
    type: str
    idea: str

@dataclass
class Caption:
    text: str

@dataclass
class ScheduleItem:
    id: int; content: ContentIdea; scheduled_time: datetime; status: str

# ------------------  10×3×10 FALLBACK BANKS  ---------------------------------
NICHE_BANKS = {
    "fashion": {
        "captions": [
            "🔥 Which look wins—1 or 2? Drop 🔥 below! #OOTD #fashion",
            "👗 Thrift flip: $5 → runway fit. Save for inspo! #thrift #style",
            "👖 Denim 101: find your perfect cut—swipe for guide #denim #fashiontips",
            "✨ 3 pieces that instantly elevate ANY outfit #stylehack #fashion",
            "🌈 Colour-blocking made easy—tag a colour-lover #colourful #outfit",
            "👠 Shoe game strong—what's your go-to pair? #shoes #fashion",
            "🧥 Layering season is HERE—save this cheat-sheet #layering #fallstyle",
            "💡 1 belt, 5 fits—carousel inside #accessorize #fashionhacks",
            "🕶️ Street-style spotlight: which city next? #streetwear #fashion",
            "🌱 Sustainable fashion finds under $30—link in bio #sustainable #ethicalfashion",
        ],
        "ideas": [
            ("reel", "3 ways to style 1 blazer—challenge yourself"),
            ("carousel", "Capsule wardrobe checklist—save & shop smart"),
            ("image", "Flat-lay colour story—pick palette & tag us"),
            ("story", "Poll: skinny vs wide jeans—what wins?"),
            ("reel", "Thrift haul try-on—$20 total spend"),
            ("carousel", "Denim fits explained—find your cut"),
            ("image", "Outfit mirror selfie—morning vs night look"),
            ("story", "Quiz: guess designer vs dupe price"),
            ("reel", "Pack 7 outfits in 1 carry-on—travel hack"),
            ("carousel", "Accessory trends 2025—swipe to shop"),
        ],
        "schedule": [
            "Monday: Outfit inspo flat-lay",
            "Tuesday: Trend alert carousel",
            "Wednesday: Thrift haul reel",
            "Thursday: Styling tutorial",
            "Friday: Drop announcement",
            "Saturday: Street style shoot",
            "Sunday: Capsule recap",
            "Week 2: Denim deep dive",
            "Week 2: Accessory spotlight",
            "Week 2: Sustainable switch",
        ],
    },
    "food": {
        "captions": [
            "🍝 One-pot pasta = less dishes, more flavour. Save recipe! #foodie #easyrecipe",
            "🌮 Taco Tuesday sorted—swipe for filling ideas #taco #food",
            "🥑 Avocado toast 5 ways—tag your brunch buddy #avocado #brunch",
            "🔥 Air-fryer magic: crispy fries in 15 min—no oil! #airfryer #healthy",
            "🍳 Breakfast for dinner—yes or no? Vote in stories #breakfast #food",
            "🌱 Vegan swap: cashew cream vs dairy—try it #vegan #plantbased",
            "🍕 Homemade dough in 30 min—no fail recipe inside #pizza #DIY",
            "🍜 Ramen upgrade: pantry staples transform packet #ramen #hack",
            "🍰 3-ingredient mug cake—late-night fix #dessert #mugcake",
            "🍉 Summer fruit platter that wows—save for parties #fruit #summer",
        ],
        "ideas": [
            ("reel", "Speed-run: 5-minute stir-fry dinner"),
            ("carousel", "Meal-prep 5 lunches under $20—shop & cook"),
            ("image", "Flat-lay of today's farmers' market haul"),
            ("story", "Poll: sweet vs savoury breakfast?"),
            ("reel", "Air-fryer only: crispy chicken thighs"),
            ("carousel", "Pasta shape + sauce pairing guide"),
            ("image", "Before/After: pantry organisation"),
            ("story", "Quiz: guess spice from close-up"),
            ("reel", "Dough rise time-lapse—watch it grow"),
            ("carousel", "Vegan protein sources—save list"),
        ],
        "schedule": [
            "Monday: Meal-prep reel",
            "Tuesday: Trending ingredient spotlight",
            "Wednesday: Quick recipe carousel",
            "Thursday: Live cook-along",
            "Friday: Dessert drop",
            "Saturday: Market haul stories",
            "Sunday: Reader feature (remake)",
            "Week 2: Vegan week special",
            "Week 2: Air-fryer only",
            "Week 2: Global cuisine Monday",
        ],
    },
    "fitness": {
        "captions": [
            "💪 15-min dumbbell circuit—no gym needed. Save & sweat later! #fitness #homeworkout",
            "🏃‍♀️ 5 k in 25 min—try this pace chart. Tag runner buddy! #running #cardio",
            "🧘‍♂️ 10-min morning stretch—wake up pain-free. #mobility #wellness",
            "🔥 HIIT timer: 40 s on / 20 s off—8 rounds. Timer in bio! #hiit #fatloss",
            "🥗 Protein pancake recipe—post-leg day fuel. #fitfood #gains",
            "🚴‍♂️ Cycle session: hill climb simulation. Who's in? #cycling #indoor",
            "🤸‍♀️ Plank challenge: can you hit 3 min? Reply time! #plank #core",
            "🧠 Mind-muscle connection tip—feel the burn more #gymtips #train",
            "🛌 Recovery day: why rest grows muscle. Save reminder #recovery #rest",
            "🎯 Goal setting: write 2025 fitness target below #goals #accountability",
        ],
        "ideas": [
            ("reel", "20-min full-body dumbbell workout—follow along"),
            ("carousel", "Warm-up dynamic stretch routine—save before gym"),
            ("image", "Progress pic: 8-week arm growth—natural lighting"),
            ("story", "Poll: morning vs evening workout?"),
            ("reel", "Zero-equipment hotel room workout—travel fit"),
            ("carousel", "Macros 101—how to count & why"),
            ("image", "Quote: 'Discipline > motivation'—gym wall art"),
            ("story", "Countdown: live workout tonight 7 PM"),
            ("reel", "Meal-prep 5 high-protein lunches—speed-run"),
            ("carousel", "Running shoes 2025—top 5 picks"),
        ],
        "schedule": [
            "Monday: Full-body dumbbell reel",
            "Tuesday: Nutrition carousel",
            "Wednesday: Running tip post",
            "Thursday: Live stretch session",
            "Friday: Flex Friday pic",
            "Saturday: Recipe share",
            "Sunday: Goal check-in stories",
            "Week 2: Pull-up progression",
            "Week 2: Supplement myth buster",
            "Week 2: Sleep hygiene post",
        ],
    },
    "travel": {
        "captions": [
            "✈️ $200 weekend getaway—full itinerary in bio. Save for later! #travel #budget",
            "🌍 Hidden beach w/ no tourists—tag travel buddy #hiddenparadise #travel",
            "🎒 Carry-on only: 7-day packing list—swipe #packing #travelhack",
            "🌅 Sunrise spot locals keep secret—pin location in stories #sunrise #travel",
            "🏨 Boutique hotel under $100—link in bio #hotel #budget",
            "🚆 Train vs plane: cheaper & prettier—compare reel #traintravel #slowtravel",
            "📸 Insta-worthy angle: how to find it—save tip #photography #travel",
            "🍜 Street food tour: $5 full belly—watch & drool #streetfood #travel",
            "🗺️ Google My Maps tutorial—plan your own route #travelplanning #map",
            "🛂 Visa-free countries for US passport—save list #visa #traveltips",
        ],
        "ideas": [
            ("reel", "Pack 7 days in carry-on—folding hack tutorial"),
            ("carousel", "Visa-free countries list—save passport page"),
            ("image", "Sunrise golden hour shot—location tag"),
            ("story", "Poll: window or aisle seat?"),
            ("reel", "Street food tour—$5 full meal"),
            ("carousel", "Offline maps setup—never get lost"),
            ("image", "Flat-lay: travel essentials only"),
            ("story", "Quiz: guess country from flag emoji"),
            ("reel", "Hotel room workout—no gym needed"),
            ("carousel", "Budget breakdown: 3-day trip under $300"),
        ],
        "schedule": [
            "Monday: Packing hack reel",
            "Tuesday: Budget tip carousel",
            "Wednesday: Food tour story",
            "Thursday: Live Q&A",
            "Friday: Photo spot reveal",
            "Saturday: Weekend trip vlog",
            "Sunday: Goal check-in",
            "Week 2: Visa guide",
            "Week 2: Scam awareness",
            "Week 2: Eco travel post",
        ],
    },
    "beauty": {
        "captions": [
            "💋 5-min everyday makeup—products listed. Save for busy mornings! #beauty #makeup",
            "🌿 Skincare fridge: worth it? My honest take #skincare #beauty",
            "✨ Highlighter hack: spoon for sharp cheek—watch reel #makeuphack #beauty",
            "👁️ Hooded eye tutorial—finally a crease that shows #eyemakeup #beauty",
            "🧴 Sunscreen 101: SPF 50 vs 30—save guide #spf #skincare",
            "💅 DIY gel nails at home—$30 kit vs salon #nails #DIY",
            "🌸 Blush placement for round face—swipe diagram #blush #makeup",
            "🧼 Double cleanse demo: melt then foam #cleansing #skincare",
            "💄 Lip liner overdraw—natural fuller look #lipliner #beauty",
            "🌙 Night routine: repair while you sleep #nightroutine #skincare",
        ],
        "ideas": [
            ("reel", "5-min everyday makeup—follow along timer"),
            ("carousel", "Skincare layering order—save routine"),
            ("image", "Flat-lay: today's beauty haul"),
            ("story", "Poll: glossy vs matte lips?"),
            ("reel", "Heatless curls overnight—robe belt hack"),
            ("carousel", "Eyeshadow for hooded eyes—step pics"),
            ("image", "Before/After: brow lamination"),
            ("story", "Quiz: guess SPF rating window"),
            ("reel", "Double cleanse demo—melt & foam"),
            ("carousel", "Brush cleaning guide—avoid breakouts"),
        ],
        "schedule": [
            "Monday: Makeup tutorial reel",
            "Tuesday: Skincare science carousel",
            "Wednesday: Nail art story",
            "Thursday: Live GRWM",
            "Friday: Product review post",
            "Saturday: Self-care routine",
            "Sunday: Community spotlight",
            "Week 2: Clean beauty week",
            "Week 2: Festival makeup series",
            "Week 2: Drugstore favourites",
        ],
    },
    "pets": {
        "captions": [
            "🐾 Morning zoomies—captured in slow-mo. Save & share the chaos! #pets #dog",
            "🐱 Cat logic: sits in box, ignores bed. Relatable? #cat #pets",
            "🐶 Puppy training 101: sit, stay, treat—repeat x100 #puppy #training",
            "🦜 Parrot says 'I love you'—wait for it #parrot #pets",
            "🐹 Hamster maze build—DIY enrichment #hamster #pets",
            "🐠 Tank clean timelapse—satisfying watch #aquarium #pets",
            "🐇 Bunny flop = pure happiness #bunny #pets",
            "🐾 Paw print art—keepsake tutorial #diy #pets",
            "🦎 Leopard gecko care—beginner guide #reptile #pets",
            "🐕‍🦺 Service dog vest meaning—educate yourself #servicedog #pets",
        ],
        "ideas": [
            ("reel", "Puppy zoomies slow-mo—pure joy"),
            ("carousel", "Cat body language guide—tail talk"),
            ("image", "Flat-lay: pet first aid kit"),
            ("story", "Poll: dogs vs cats?"),
            ("reel", "Hamster maze build—DIY enrichment"),
            ("carousel", "Dog training basics—sit stay come"),
            ("image", "Before/After: groom makeover"),
            ("story", "Quiz: guess breed from puppy pic"),
            ("reel", "Parrot says 'hello'—talking comp"),
            ("carousel", "Aquarium setup step-by-step"),
        ],
        "schedule": [
            "Monday: Puppy training reel",
            "Tuesday: Cat behaviour carousel",
            "Wednesday: Small pet care story",
            "Thursday: Live Q&A vet nurse",
            "Friday: Funny pet compilation",
            "Saturday: Adoption event promo",
            "Sunday: Community pet feature",
            "Week 2: Aquarium focus",
            "Week 2: Bird training series",
            "Week 2: Rabbit diet special",
        ],
    },
    "business": {
        "captions": [
            "💡 Idea validation: 3 questions before you build. Save & ask! #business #startup",
            "📈 Revenue milestone: first $10 k—how I did it #revenue #entrepreneur",
            "🚀 Side hustle stack: combine skills for cash—examples inside #sidehustle #business",
            "🧮 Break-even calc: know your numbers—template free #finance #business",
            "🤝 Cold email script: land clients without ads—copy & paste #coldemail #sales",
            "📊 KPI dashboard: track what matters—Google sheet link #kpi #business",
            "🎯 Niche down: riches in the niches—car inside #niche #business",
            "🧠 Mindset shift: sell outcome, not hours #mindset #sales",
            "💰 Pricing hack: add 0 to your rate—test confidence #pricing #business",
            "📚 3 books that grew my biz—save list #books #entrepreneur",
        ],
        "ideas": [
            ("reel", "Idea validation: 3 questions before you build"),
            ("carousel", "Break-even calculation—template free"),
            ("image", "Screenshot: first Stripe payout notification"),
            ("story", "Poll: freelance vs product biz?"),
            ("reel", "Cold email script—copy & paste"),
            ("carousel", "KPI dashboard—Google sheet link"),
            ("image", "Flat-lay: daily productivity tools"),
            ("story", "Quiz: guess monthly revenue"),
            ("reel", "MVP build: no code tools tour"),
            ("carousel", "Tax write-off checklist—save money"),
        ],
        "schedule": [
            "Monday: Idea validation reel",
            "Tuesday: Finance template carousel",
            "Wednesday: Cold email story",
            "Thursday: Live build session",
            "Friday: Launch checklist post",
            "Saturday: Testimonial feature",
            "Sunday: Goal reflection",
            "Week 2: KPI deep dive",
            "Week 2: Tax prep special",
            "Week 2: Content batching",
        ],
    },
}

# ------------------  FALLBACK PICKERS  ---------------------------------------
def pick_fallback_captions(niche: str, k: int = 10) -> List[str]:
    pool = NICHE_BANKS.get(niche, NICHE_BANKS["business"])["captions"]
    tag = niche.replace(" ", "")
    return [random.choice(pool).replace("{niche}", niche).replace("{tag}", tag) for _ in range(k)]

def pick_fallback_ideas(niche: str, k: int = 10) -> List[ContentIdea]:
    pool = NICHE_BANKS.get(niche, NICHE_BANKS["business"])["ideas"]
    tag = niche.replace(" ", "")
    # Cycle through pool to allow more than 10 items
    result = []
    for i in range(k):
        tp, idea = pool[i % len(pool)]
        result.append(ContentIdea(
            type=tp,
            idea=idea.replace("{niche}", niche).replace("{tag}", tag) + f" (Day {i+1})"
        ))
    return result

def pick_fallback_schedule_topics(niche: str, k: int = 10) -> List[str]:
    pool = NICHE_BANKS.get(niche, NICHE_BANKS["business"])["schedule"]
    tag = niche.replace(" ", "")
    return [random.choice(pool).replace("{niche}", niche).replace("{tag}", tag) for _ in range(k)]

# ------------------------------------------------------------------
#  ENSURE HELPERS
# ------------------------------------------------------------------
def _ensure_ideas(niche: str, ideas: List[ContentIdea], min_len: int = 1) -> List[ContentIdea]:
    if ideas and len(ideas) >= min_len:
        return ideas
    return pick_fallback_ideas(niche, min_len)

def _ensure_captions(niche: str, captions: List[Caption]) -> List[Caption]:
    if captions and len(captions) >= 5:
        return captions
    return [Caption(text=c) for c in pick_fallback_captions(niche, 10)]

# ------------------  GEMINI CLIENT  -------------------------------------------
class GeminiAI:
    def __init__(self, api_key: str):
        self.key = api_key.strip()
        self.url = "https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash-latest:generateContent"
        self.enabled = bool(self.key)
    async def generate(self, prompt: str, temp: float = .7, max_tokens: int = 2000) -> str:
        if not self.enabled: return ""
        payload = {"contents": [{"parts": [{"text": prompt}]}],
                   "generationConfig": {"temperature": temp, "maxOutputTokens": max_tokens}}
        try:
            async with aiohttp.ClientSession() as s:
                async with s.post(f"{self.url}?key={self.key}", json=payload, timeout=30) as r:
                    if r.status == 200:
                        cand = (await r.json()).get("candidates", [])
                        if cand: return cand[0]["content"]["parts"][0]["text"].strip()
        except Exception as e:
            print("⚠️ Gemini error:", str(e))
        return ""

# ------------------  WEB SCRAPER  ---------------------------------------------
class WebScraper:
    def __init__(self, serper_key: str): self.key = serper_key.strip()
    async def scrape(self, niche: str, kw: List[str]) -> List[Dict]:
        tags: List[Dict] = []
        if self.key:
            tags.extend(await self._serper(niche, kw))
        return tags
    async def _serper(self, niche: str, kw: List[str]) -> List[Dict]:
        q = f"top Instagram hashtags for {niche} {' '.join(kw[:2])} 2024"
        payload = {"q": q, "num_results": 20}
        hdr = {"X-API-KEY": self.key, "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as s:
                async with s.post("https://google.serper.dev/search", json=payload, headers=hdr, timeout=20) as r:
                    if r.status == 200:
                        ser = await r.json()
                        tags = []
                        for item in ser.get("organic", []):
                            txt = f"{item.get('title','')} {item.get('snippet','')}"
                            for t in re.findall(r"#(\w+)", txt):
                                if 3 <= len(t) <= 25: tags.append({"tag": f"#{t.lower()}", "source": "serper"})
                        ab = ser.get("answerBox", {})
                        if ab:
                            for t in re.findall(r"#(\w+)", str(ab)):
                                if 3 <= len(t) <= 25: tags.append({"tag": f"#{t.lower()}", "source": "serper"})
                        for paa in ser.get("peopleAlsoAsk", []):
                            for t in re.findall(r"#(\w+)", str(paa)):
                                if 3 <= len(t) <= 25: tags.append({"tag": f"#{t.lower()}", "source": "serper"})
                        return tags[:30]
        except Exception as e:
            print("Serper scrape error:", str(e))
        return []

# ------------------  AGENT 1  –  LIVE SCRAPE → GEMINI  ------------------------
class HashtagScraperAgent:
    def __init__(self, ai: GeminiAI, scraper: WebScraper):
        self.ai = ai; self.scraper = scraper
    async def analyze(self, niche: str, kw: List[str]) -> List[Hashtag]:
        print("🔍 Agent-1 – live scrape + Gemini trending …")
        raw = await self.scraper.scrape(niche, kw)
        if not raw:
            print("   ⚠️  Serper empty – asking Gemini for trending …")
            gem_raw = await self.ai.generate(
                f"List 20 trending Instagram hashtags for {niche} keywords {','.join(kw)}. Return only hashtags, 1 per line.",
                temp=.8)
            for line in gem_raw.splitlines():
                t = line.strip()
                if t.startswith('#'): raw.append({"tag": t.lower(), "source": "gemini"})
        seen = set(); out = []
        for item in raw:
            tag = item["tag"].lower()
            if tag in seen or len(tag) < 3: continue
            seen.add(tag)
            posts = f"{random.randint(200,2000)}K" if len(tag) > 10 else f"{random.randint(5,20)}M+"
            out.append(Hashtag(tag=tag, posts=posts, competition="medium" if "M" in posts else "low",
                               relevance=round(random.uniform(.75, .95), 2), source=item.get("source", "mix")))
        if not out:
            print("   ⚠️  ZERO hashtags – returning fallback fitness list")
            fallback = ["#fitness", "#gym", "#workout", "#motivation", "#health", "#wellness", "#fitlife", "#training", "#exercise", "#strong"]
            for t in fallback:
                out.append(Hashtag(tag=t, posts=f"{random.randint(5,20)}M+", competition="medium",
                                   relevance=0.85, source="zero_fallback"))
        out.sort(key=lambda x: x.relevance, reverse=True)
        with open(OUTPUT_DIR / "hashtags.json", "w", encoding="utf8") as f:
            json.dump({"niche": niche, "date": datetime.now().isoformat(), "hashtags": [asdict(h) for h in out]}, f, indent=2)
        print(f"✅ Agent-1 done – {len(out)} hashtags")
        return out

# ------------------  AGENT 2  –  RAW CONTENT IDEAS ONLY  ----------------------
class ContentPlannerAgent:
    def __init__(self, ai: GeminiAI): self.ai = ai
    async def plan(self, niche: str, hashtags: List[Hashtag], days: int) -> List[ContentIdea]:
        print("🎨 Agent-2 – generating raw content ideas …")
        ideas: List[ContentIdea] = []
        used = set()
        prompt = (
            f"Give {days} different Instagram content IDEAS for the '{niche}' niche. "
            "Each idea must be unique (no repeated concepts). "
            "Output 1 idea per line in this exact format:\n"
            "TYPE: <reel|carousel|image|story>\n"
            "IDEA: <short 1-sentence creative prompt>\n\n"
            "Do NOT include timings, captions, or hashtags."
        )
        resp = await self.ai.generate(prompt, temp=0.9, max_tokens=2000)
        if resp:
            for block in resp.splitlines():
                block = block.strip()
                if block.startswith("TYPE:"):
                    post_type = block.replace("TYPE:", "").strip().lower()
                elif block.startswith("IDEA:"):
                    idea_txt = block.replace("IDEA:", "").strip()
                    if idea_txt and idea_txt not in used:
                        used.add(idea_txt)
                        ideas.append(ContentIdea(type=post_type, idea=idea_txt))
        ideas = _ensure_ideas(niche, ideas, days)
        with open(OUTPUT_DIR / "content_ideas.json", "w", encoding="utf8") as f:
            json.dump({"niche": niche, "date": datetime.now().isoformat(),
                       "ideas": [asdict(i) for i in ideas]}, f, indent=2)
        print(f"✅ Agent-2 done – {len(ideas)} fresh ideas")
        return ideas

# ------------------  AGENT 3  –  SCHEDULER (1-POST-PER-DAY)  -----------------
class ScheduleManagerAgent:
    def organise(self, ideas: List[ContentIdea], days: int,
                 start: Optional[str] = None) -> List[ScheduleItem]:
        ideas = _ensure_ideas("business", ideas, days)  # guarantee *days* ideas
        ai_time = self._ask_gemini_times(ideas[0].type if ideas else "reel")[0]
        hour = int(ai_time.split(":")[0]) if ":" in ai_time else 18
        start_dt = datetime.strptime(start, "%Y-%m-%d") if start \
                   else datetime.now() + timedelta(days=1)
        items, pid = [], 1
        for d in range(days):                       # 1 row per calendar day
            dt = start_dt + timedelta(days=d, hours=hour)
            items.append(ScheduleItem(id=pid,
                                      content=ideas[d],
                                      scheduled_time=dt,
                                      status="scheduled"))
            pid += 1
        with open(OUTPUT_DIR / "schedule.json", "w", encoding="utf8") as f:
            json.dump({"date": datetime.now().isoformat(),
                       "schedule": [{"id": it.id,
                                     "content": asdict(it.content),
                                     "scheduled_time": it.scheduled_time.isoformat(),
                                     "status": it.status} for it in items]}, f, indent=2)
        return items

    def _ask_gemini_times(self, niche: str) -> List[str]:
        resp = asyncio.run(GeminiAI(GEMINI_API_KEY).generate(
            f"List 1 best posting time (HH:00) for Instagram {niche} niche.", temp=.7))
        times = [re.search(r"(\d{1,2}):00", line).group(1)+":00"
                 for line in resp.splitlines() if re.search(r"(\d{1,2}):00", line)]
        return times if times else ["18:00"]

# ------------------  AGENT 4  –  CAPTION AGENT  ------------------------------
class CaptionAgent:
    def __init__(self, ai: GeminiAI): self.ai = ai
    async def generate_captions(self, niche: str, hashtags: List[Hashtag]) -> List[Caption]:
        print("📝 Agent-4 – writing captions …")
        tag_string = " ".join([h.tag for h in hashtags[:10]])
        prompt = (
            f"Write 20 different Instagram captions for the '{niche}' niche. "
            "Each caption must be unique, 1-2 sentences, include emojis, a CTA, and 5-7 hashtags. "
            "Output 1 caption per line only—no labels, no bullets."
        )
        resp = await self.ai.generate(prompt, temp=0.8, max_tokens=2000)
        captions = []
        if resp:
            for line in resp.splitlines():
                line = line.strip()
                if len(line) > 20:
                    captions.append(Caption(text=line))
        captions = _ensure_captions(niche, captions)
        with open(OUTPUT_DIR / "captions.json", "w", encoding="utf8") as f:
            json.dump({"niche": niche, "date": datetime.now().isoformat(),
                       "captions": [asdict(c) for c in captions]}, f, indent=2)
        print(f"✅ Agent-4 done – {len(captions)} captions")
        return captions

# ------------------  ORCHESTRATOR  -------------------------------------------
class Orchestrator:
    def __init__(self):
        self.ai   = GeminiAI(GEMINI_API_KEY)
        self.scraper = WebScraper(SERPER_API_KEY)
        self.a1 = HashtagScraperAgent(self.ai, self.scraper)
        self.a2 = ContentPlannerAgent(self.ai)
        self.a3 = ScheduleManagerAgent()
        self.a4 = CaptionAgent(self.ai)

    # ORDER: content → hashtag → caption → schedule
    async def run_complete(self, niche: str, kw: List[str], days: int,
                         start: Optional[str] = None) -> Dict:
        ideas    = await self.a2.plan(niche, [], days)
        hashtags = await self.a1.analyze(niche, kw)
        captions = await self.a4.generate_captions(niche, hashtags)
        sched    = self.a3.organise(ideas, days, start)
        return {"ideas": ideas, "hashtags": hashtags,
                "captions": captions, "schedule": sched}

    async def run_agent(self, num: int, niche: str, kw: List[str], days: int = 7):
        if num == 1: return await self.a1.analyze(niche, kw)
        if num == 2:
            h = await self.a1.analyze(niche, kw); return await self.a2.plan(niche, h, days)
        if num == 3:
            h = await self.a1.analyze(niche, kw); c = await self.a2.plan(niche, h, days); return self.a3.organise(c, days)
        if num == 4:
            h = await self.a1.analyze(niche, kw); return await self.a4.generate_captions(niche, h)

# ------------------  GRADIO HANDLER  ------------------------------------------
orch = Orchestrator()

def fmt_hash(h):
    if not h: return "❌ No hashtags"
    rows = "| # | Hashtag | Posts | Competition | Relevance |\n|---|---------|-------|-------------|-----------|\n"
    for i, hashtag in enumerate(h[:20], 1):
        rows += f"| {i} | `{hashtag.tag}` | {hashtag.posts} | {hashtag.competition} | {hashtag.relevance} |\n"
    return "🏷️ **Hashtags**\n\n" + rows

def fmt_ideas(p):
    if not p: return "❌ No content ideas"
    rows = "| # | Type | Idea |\n|---|------|------|\n"
    for i, idea in enumerate(p[:20], 1):
        rows += f"| {i} | **{idea.type.upper()}** | {idea.idea} |\n"
    return "💡 **Content Ideas**\n\n" + rows

def fmt_sched(s):
    if not s: return "❌ No schedule"
    rows = "| Day | Date / Time | Content Idea |\n|-----|-------------|--------------|\n"
    for it in s:
        t12 = it.scheduled_time.strftime("%a %d %b %I:%M %p")
        rows += f"| {it.id} | {t12} | {it.content.idea[:70]}… |\n"
    return "📅 **Schedule**\n\n" + rows

def fmt_captions(cap):
    if not cap: return "❌ No captions"
    rows = "| # | Caption |\n|---|---------|\n"
    for i, c in enumerate(cap[:20], 1):
        rows += f"| {i} | {c.text} |\n"
    return "📝 **Captions**\n\n" + rows

def handle(niche, keywords, days, start_date, agent_choice):
    if not niche.strip():
        return ["❌ Please enter a niche"] + [""]*4
    kw_list  = [k.strip() for k in keywords.split(",")] if keywords else [niche]
    choice   = agent_choice.split(" ")[0]
    days     = int(days) if str(days).isdigit() else 7
    start    = start_date if start_date else None

    def _run(coro):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try: return loop.run_until_complete(coro)
        finally: loop.close()

    try:
        if choice == "✨":
            res = _run(orch.run_complete(niche, kw_list, days, start))
            return ["✅ Full pipeline finished – files saved",
                    fmt_hash(res["hashtags"]),
                    fmt_ideas(res["ideas"]),
                    fmt_sched(res["schedule"]),
                    fmt_captions(res["captions"])]
        elif choice == "🎨":
            c = _run(orch.run_agent(2, niche, kw_list, days))
            return ["✅ Agent-2 done", "", fmt_ideas(c), "", ""]
        elif choice == "🏷️":
            h = _run(orch.run_agent(1, niche, kw_list))
            return ["✅ Agent-1 done", fmt_hash(h), "", "", ""]
        elif choice == "📅":
            s = _run(orch.run_agent(3, niche, kw_list, days))
            return ["✅ Agent-3 done", "", "", fmt_sched(s), ""]
        elif choice == "📝":
            cap = _run(orch.run_agent(4, niche, kw_list))
            return ["✅ Agent-4 done", "", "", "", fmt_captions(cap)]
        else:
            return ["❌ Unknown choice"] + [""]*4
    except Exception as e:
        return [f"❌ Error: {e}"] + [""]*4

# ------------------  GRADIO UI  -----------------------------------------------
with gr.Blocks(title="InstaGrowth AI – 4-Agent System", theme=gr.themes.Soft()) as demo:
    gr.Markdown("# 🚀 InstaGrowth AI – 4-Agent Instagram Growth System")
    gr.Markdown("**AI that Thinks Like a Marketer — For Growth that Feels Organic**")

    with gr.Row():
        with gr.Column(scale=1):
            niche_in   = gr.Textbox(label="Niche", placeholder="e.g. fitness")
            kw_in      = gr.Textbox(label="Keywords (comma)", placeholder="gym, exercise")
            days_in    = gr.Slider(3, 10, value=7, step=1, label="Days (max 10)")
            start_in   = gr.Textbox(label="Start date YYYY-MM-DD (opt)")
            agent_dd   = gr.Dropdown(
                ["✨ Use all agents together",
                 "🎨 Content ideas",
                 "🏷️ Hashtags",
                 "📝 Captions",
                 "📅 Scheduling"],
                label="Agent choice", value="✨ Use all agents together")
            run_btn = gr.Button("Run", variant="primary", size="lg")

            with gr.Column(visible=False) as confirm_col:
                confirm_md = gr.Markdown("✅ Full pipeline finished – files saved")
                with gr.Row():
                    copy_btn  = gr.Button("📋 Copy to clipboard", size="sm")
                    down_btn  = gr.Button("💾 Download ZIP", size="sm")

        with gr.Column(scale=2):
            output_md = gr.Markdown()

    zip_file = gr.File(label="download", visible=False)

    def _make_zip():
        zf = tempfile.NamedTemporaryFile(delete=False, suffix=".zip")
        with zipfile.ZipFile(zf, "w", zipfile.ZIP_DEFLATED) as z:
            for f in ["hashtags.json", "content_ideas.json", "schedule.json", "captions.json"]:
                p = OUTPUT_DIR / f
                if p.exists(): z.write(p, f)
        zf.close(); return zf.name

    def run_pipeline(niche, keywords, days, start_date, agent_choice):
        if not niche.strip():
            return [gr.update(visible=False), "❌ Please enter a niche", None]
        kw_list = [k.strip() for k in keywords.split(",")] if keywords else [niche]
        choice  = agent_choice.split(" ")[0]
        days    = int(days) if str(days).isdigit() else 7
        start   = start_date if start_date else None

        def _run(coro):
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try: return loop.run_until_complete(coro)
            finally: loop.close()

        try:
            if choice == "✨":
                res = _run(orch.run_complete(niche, kw_list, days, start))
                txt = f"{fmt_hash(res['hashtags'])}\n\n{fmt_ideas(res['ideas'])}\n\n{fmt_sched(res['schedule'])}\n\n{fmt_captions(res['captions'])}"
                return [gr.update(visible=True), txt, _make_zip()]
            elif choice == "🎨":
                c = _run(orch.run_agent(2, niche, kw_list, days))
                return [gr.update(visible=True), fmt_ideas(c), None]
            elif choice == "🏷️":
                h = _run(orch.run_agent(1, niche, kw_list))
                return [gr.update(visible=True), fmt_hash(h), None]
            elif choice == "📝":
                cap = _run(orch.run_agent(4, niche, kw_list))
                return [gr.update(visible=True), fmt_captions(cap), None]
            elif choice == "📅":
                s = _run(orch.run_agent(3, niche, kw_list, days))
                return [gr.update(visible=True), fmt_sched(s), None]
            else:
                return [gr.update(visible=False), "❌ Unknown choice", None]
        except Exception as e:
            return [gr.update(visible=False), f"❌ Error: {e}", None]

    run_btn.click(run_pipeline, [niche_in, kw_in, days_in, start_in, agent_dd],
                  [confirm_col, output_md, zip_file])
    copy_btn.click(None, [], [], js="""
        () => navigator.clipboard.writeText(document.querySelector('.prose').innerText)""")
    down_btn.click(lambda f: f, inputs=[zip_file], outputs=[zip_file])

# ---------- KEEP CELL ALIVE ----------
demo.queue().launch(height=800, inline=True, share=True, prevent_thread_lock=True)
import threading, time
while True: time.sleep(1)