# -*- coding: utf-8 -*-
"""InstaGrowthAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oank_aE2iAt6mK44RLtKFCTU0EVqFAWW

InstaGrowth AI Agent
"""

# ==============================================================================
#  InstaGrowth AI ‚Äì 4-Agent System  (10 CAP/IDEA/SCH per niche ‚Üí 10√ó3√ó10 = 300)
# ==============================================================================
import subprocess, sys, os, json, re, random, asyncio, gradio as gr, nest_asyncio, time, tempfile, zipfile
from datetime import datetime, timedelta
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import List, Optional, Dict

for pkg in ["aiohttp", "beautifulsoup4", "nest_asyncio"]:
    try: __import__(pkg)
    except: subprocess.check_call([sys.executable, "-m", "pip", "-q", "install", pkg])
import aiohttp
nest_asyncio.apply()

# ------------------  CONFIG  --------------------------------------------------
GEMINI_API_KEY = "AIzaSyDu61_VRLto6Y_n7R4SGcjGg_5oUQFhMo4"   # <-- CHANGE
SERPER_API_KEY = "f3ea8d71be452ba200d0cb5969ec59568a51b7b5"   # <-- CHANGE
OUTPUT_DIR = Path("instagrowth_ai_data")
OUTPUT_DIR.mkdir(exist_ok=True)

# ------------------  DATA MODELS  ---------------------------------------------
@dataclass
class Hashtag:
    tag: str; posts: str; relevance: float; competition: str; source: str

@dataclass
class ContentIdea:
    type: str
    idea: str

@dataclass
class Caption:
    text: str

@dataclass
class ScheduleItem:
    id: int; content: ContentIdea; scheduled_time: datetime; status: str

# ------------------  10√ó3√ó10 FALLBACK BANKS  ---------------------------------
NICHE_BANKS = {
    "fashion": {
        "captions": [
            "üî• Which look wins‚Äî1 or 2? Drop üî• below! #OOTD #fashion",
            "üëó Thrift flip: $5 ‚Üí runway fit. Save for inspo! #thrift #style",
            "üëñ Denim 101: find your perfect cut‚Äîswipe for guide #denim #fashiontips",
            "‚ú® 3 pieces that instantly elevate ANY outfit #stylehack #fashion",
            "üåà Colour-blocking made easy‚Äîtag a colour-lover #colourful #outfit",
            "üë† Shoe game strong‚Äîwhat's your go-to pair? #shoes #fashion",
            "üß• Layering season is HERE‚Äîsave this cheat-sheet #layering #fallstyle",
            "üí° 1 belt, 5 fits‚Äîcarousel inside #accessorize #fashionhacks",
            "üï∂Ô∏è Street-style spotlight: which city next? #streetwear #fashion",
            "üå± Sustainable fashion finds under $30‚Äîlink in bio #sustainable #ethicalfashion",
        ],
        "ideas": [
            ("reel", "3 ways to style 1 blazer‚Äîchallenge yourself"),
            ("carousel", "Capsule wardrobe checklist‚Äîsave & shop smart"),
            ("image", "Flat-lay colour story‚Äîpick palette & tag us"),
            ("story", "Poll: skinny vs wide jeans‚Äîwhat wins?"),
            ("reel", "Thrift haul try-on‚Äî$20 total spend"),
            ("carousel", "Denim fits explained‚Äîfind your cut"),
            ("image", "Outfit mirror selfie‚Äîmorning vs night look"),
            ("story", "Quiz: guess designer vs dupe price"),
            ("reel", "Pack 7 outfits in 1 carry-on‚Äîtravel hack"),
            ("carousel", "Accessory trends 2025‚Äîswipe to shop"),
        ],
        "schedule": [
            "Monday: Outfit inspo flat-lay",
            "Tuesday: Trend alert carousel",
            "Wednesday: Thrift haul reel",
            "Thursday: Styling tutorial",
            "Friday: Drop announcement",
            "Saturday: Street style shoot",
            "Sunday: Capsule recap",
            "Week 2: Denim deep dive",
            "Week 2: Accessory spotlight",
            "Week 2: Sustainable switch",
        ],
    },
    "food": {
        "captions": [
            "üçù One-pot pasta = less dishes, more flavour. Save recipe! #foodie #easyrecipe",
            "üåÆ Taco Tuesday sorted‚Äîswipe for filling ideas #taco #food",
            "ü•ë Avocado toast 5 ways‚Äîtag your brunch buddy #avocado #brunch",
            "üî• Air-fryer magic: crispy fries in 15 min‚Äîno oil! #airfryer #healthy",
            "üç≥ Breakfast for dinner‚Äîyes or no? Vote in stories #breakfast #food",
            "üå± Vegan swap: cashew cream vs dairy‚Äîtry it #vegan #plantbased",
            "üçï Homemade dough in 30 min‚Äîno fail recipe inside #pizza #DIY",
            "üçú Ramen upgrade: pantry staples transform packet #ramen #hack",
            "üç∞ 3-ingredient mug cake‚Äîlate-night fix #dessert #mugcake",
            "üçâ Summer fruit platter that wows‚Äîsave for parties #fruit #summer",
        ],
        "ideas": [
            ("reel", "Speed-run: 5-minute stir-fry dinner"),
            ("carousel", "Meal-prep 5 lunches under $20‚Äîshop & cook"),
            ("image", "Flat-lay of today's farmers' market haul"),
            ("story", "Poll: sweet vs savoury breakfast?"),
            ("reel", "Air-fryer only: crispy chicken thighs"),
            ("carousel", "Pasta shape + sauce pairing guide"),
            ("image", "Before/After: pantry organisation"),
            ("story", "Quiz: guess spice from close-up"),
            ("reel", "Dough rise time-lapse‚Äîwatch it grow"),
            ("carousel", "Vegan protein sources‚Äîsave list"),
        ],
        "schedule": [
            "Monday: Meal-prep reel",
            "Tuesday: Trending ingredient spotlight",
            "Wednesday: Quick recipe carousel",
            "Thursday: Live cook-along",
            "Friday: Dessert drop",
            "Saturday: Market haul stories",
            "Sunday: Reader feature (remake)",
            "Week 2: Vegan week special",
            "Week 2: Air-fryer only",
            "Week 2: Global cuisine Monday",
        ],
    },
    "fitness": {
        "captions": [
            "üí™ 15-min dumbbell circuit‚Äîno gym needed. Save & sweat later! #fitness #homeworkout",
            "üèÉ‚Äç‚ôÄÔ∏è 5 k in 25 min‚Äîtry this pace chart. Tag runner buddy! #running #cardio",
            "üßò‚Äç‚ôÇÔ∏è 10-min morning stretch‚Äîwake up pain-free. #mobility #wellness",
            "üî• HIIT timer: 40 s on / 20 s off‚Äî8 rounds. Timer in bio! #hiit #fatloss",
            "ü•ó Protein pancake recipe‚Äîpost-leg day fuel. #fitfood #gains",
            "üö¥‚Äç‚ôÇÔ∏è Cycle session: hill climb simulation. Who's in? #cycling #indoor",
            "ü§∏‚Äç‚ôÄÔ∏è Plank challenge: can you hit 3 min? Reply time! #plank #core",
            "üß† Mind-muscle connection tip‚Äîfeel the burn more #gymtips #train",
            "üõå Recovery day: why rest grows muscle. Save reminder #recovery #rest",
            "üéØ Goal setting: write 2025 fitness target below #goals #accountability",
        ],
        "ideas": [
            ("reel", "20-min full-body dumbbell workout‚Äîfollow along"),
            ("carousel", "Warm-up dynamic stretch routine‚Äîsave before gym"),
            ("image", "Progress pic: 8-week arm growth‚Äînatural lighting"),
            ("story", "Poll: morning vs evening workout?"),
            ("reel", "Zero-equipment hotel room workout‚Äîtravel fit"),
            ("carousel", "Macros 101‚Äîhow to count & why"),
            ("image", "Quote: 'Discipline > motivation'‚Äîgym wall art"),
            ("story", "Countdown: live workout tonight 7 PM"),
            ("reel", "Meal-prep 5 high-protein lunches‚Äîspeed-run"),
            ("carousel", "Running shoes 2025‚Äîtop 5 picks"),
        ],
        "schedule": [
            "Monday: Full-body dumbbell reel",
            "Tuesday: Nutrition carousel",
            "Wednesday: Running tip post",
            "Thursday: Live stretch session",
            "Friday: Flex Friday pic",
            "Saturday: Recipe share",
            "Sunday: Goal check-in stories",
            "Week 2: Pull-up progression",
            "Week 2: Supplement myth buster",
            "Week 2: Sleep hygiene post",
        ],
    },
    "travel": {
        "captions": [
            "‚úàÔ∏è $200 weekend getaway‚Äîfull itinerary in bio. Save for later! #travel #budget",
            "üåç Hidden beach w/ no tourists‚Äîtag travel buddy #hiddenparadise #travel",
            "üéí Carry-on only: 7-day packing list‚Äîswipe #packing #travelhack",
            "üåÖ Sunrise spot locals keep secret‚Äîpin location in stories #sunrise #travel",
            "üè® Boutique hotel under $100‚Äîlink in bio #hotel #budget",
            "üöÜ Train vs plane: cheaper & prettier‚Äîcompare reel #traintravel #slowtravel",
            "üì∏ Insta-worthy angle: how to find it‚Äîsave tip #photography #travel",
            "üçú Street food tour: $5 full belly‚Äîwatch & drool #streetfood #travel",
            "üó∫Ô∏è Google My Maps tutorial‚Äîplan your own route #travelplanning #map",
            "üõÇ Visa-free countries for US passport‚Äîsave list #visa #traveltips",
        ],
        "ideas": [
            ("reel", "Pack 7 days in carry-on‚Äîfolding hack tutorial"),
            ("carousel", "Visa-free countries list‚Äîsave passport page"),
            ("image", "Sunrise golden hour shot‚Äîlocation tag"),
            ("story", "Poll: window or aisle seat?"),
            ("reel", "Street food tour‚Äî$5 full meal"),
            ("carousel", "Offline maps setup‚Äînever get lost"),
            ("image", "Flat-lay: travel essentials only"),
            ("story", "Quiz: guess country from flag emoji"),
            ("reel", "Hotel room workout‚Äîno gym needed"),
            ("carousel", "Budget breakdown: 3-day trip under $300"),
        ],
        "schedule": [
            "Monday: Packing hack reel",
            "Tuesday: Budget tip carousel",
            "Wednesday: Food tour story",
            "Thursday: Live Q&A",
            "Friday: Photo spot reveal",
            "Saturday: Weekend trip vlog",
            "Sunday: Goal check-in",
            "Week 2: Visa guide",
            "Week 2: Scam awareness",
            "Week 2: Eco travel post",
        ],
    },
    "beauty": {
        "captions": [
            "üíã 5-min everyday makeup‚Äîproducts listed. Save for busy mornings! #beauty #makeup",
            "üåø Skincare fridge: worth it? My honest take #skincare #beauty",
            "‚ú® Highlighter hack: spoon for sharp cheek‚Äîwatch reel #makeuphack #beauty",
            "üëÅÔ∏è Hooded eye tutorial‚Äîfinally a crease that shows #eyemakeup #beauty",
            "üß¥ Sunscreen 101: SPF 50 vs 30‚Äîsave guide #spf #skincare",
            "üíÖ DIY gel nails at home‚Äî$30 kit vs salon #nails #DIY",
            "üå∏ Blush placement for round face‚Äîswipe diagram #blush #makeup",
            "üßº Double cleanse demo: melt then foam #cleansing #skincare",
            "üíÑ Lip liner overdraw‚Äînatural fuller look #lipliner #beauty",
            "üåô Night routine: repair while you sleep #nightroutine #skincare",
        ],
        "ideas": [
            ("reel", "5-min everyday makeup‚Äîfollow along timer"),
            ("carousel", "Skincare layering order‚Äîsave routine"),
            ("image", "Flat-lay: today's beauty haul"),
            ("story", "Poll: glossy vs matte lips?"),
            ("reel", "Heatless curls overnight‚Äîrobe belt hack"),
            ("carousel", "Eyeshadow for hooded eyes‚Äîstep pics"),
            ("image", "Before/After: brow lamination"),
            ("story", "Quiz: guess SPF rating window"),
            ("reel", "Double cleanse demo‚Äîmelt & foam"),
            ("carousel", "Brush cleaning guide‚Äîavoid breakouts"),
        ],
        "schedule": [
            "Monday: Makeup tutorial reel",
            "Tuesday: Skincare science carousel",
            "Wednesday: Nail art story",
            "Thursday: Live GRWM",
            "Friday: Product review post",
            "Saturday: Self-care routine",
            "Sunday: Community spotlight",
            "Week 2: Clean beauty week",
            "Week 2: Festival makeup series",
            "Week 2: Drugstore favourites",
        ],
    },
    "pets": {
        "captions": [
            "üêæ Morning zoomies‚Äîcaptured in slow-mo. Save & share the chaos! #pets #dog",
            "üê± Cat logic: sits in box, ignores bed. Relatable? #cat #pets",
            "üê∂ Puppy training 101: sit, stay, treat‚Äîrepeat x100 #puppy #training",
            "ü¶ú Parrot says 'I love you'‚Äîwait for it #parrot #pets",
            "üêπ Hamster maze build‚ÄîDIY enrichment #hamster #pets",
            "üê† Tank clean timelapse‚Äîsatisfying watch #aquarium #pets",
            "üêá Bunny flop = pure happiness #bunny #pets",
            "üêæ Paw print art‚Äîkeepsake tutorial #diy #pets",
            "ü¶é Leopard gecko care‚Äîbeginner guide #reptile #pets",
            "üêï‚Äçü¶∫ Service dog vest meaning‚Äîeducate yourself #servicedog #pets",
        ],
        "ideas": [
            ("reel", "Puppy zoomies slow-mo‚Äîpure joy"),
            ("carousel", "Cat body language guide‚Äîtail talk"),
            ("image", "Flat-lay: pet first aid kit"),
            ("story", "Poll: dogs vs cats?"),
            ("reel", "Hamster maze build‚ÄîDIY enrichment"),
            ("carousel", "Dog training basics‚Äîsit stay come"),
            ("image", "Before/After: groom makeover"),
            ("story", "Quiz: guess breed from puppy pic"),
            ("reel", "Parrot says 'hello'‚Äîtalking comp"),
            ("carousel", "Aquarium setup step-by-step"),
        ],
        "schedule": [
            "Monday: Puppy training reel",
            "Tuesday: Cat behaviour carousel",
            "Wednesday: Small pet care story",
            "Thursday: Live Q&A vet nurse",
            "Friday: Funny pet compilation",
            "Saturday: Adoption event promo",
            "Sunday: Community pet feature",
            "Week 2: Aquarium focus",
            "Week 2: Bird training series",
            "Week 2: Rabbit diet special",
        ],
    },
    "business": {
        "captions": [
            "üí° Idea validation: 3 questions before you build. Save & ask! #business #startup",
            "üìà Revenue milestone: first $10 k‚Äîhow I did it #revenue #entrepreneur",
            "üöÄ Side hustle stack: combine skills for cash‚Äîexamples inside #sidehustle #business",
            "üßÆ Break-even calc: know your numbers‚Äîtemplate free #finance #business",
            "ü§ù Cold email script: land clients without ads‚Äîcopy & paste #coldemail #sales",
            "üìä KPI dashboard: track what matters‚ÄîGoogle sheet link #kpi #business",
            "üéØ Niche down: riches in the niches‚Äîcar inside #niche #business",
            "üß† Mindset shift: sell outcome, not hours #mindset #sales",
            "üí∞ Pricing hack: add 0 to your rate‚Äîtest confidence #pricing #business",
            "üìö 3 books that grew my biz‚Äîsave list #books #entrepreneur",
        ],
        "ideas": [
            ("reel", "Idea validation: 3 questions before you build"),
            ("carousel", "Break-even calculation‚Äîtemplate free"),
            ("image", "Screenshot: first Stripe payout notification"),
            ("story", "Poll: freelance vs product biz?"),
            ("reel", "Cold email script‚Äîcopy & paste"),
            ("carousel", "KPI dashboard‚ÄîGoogle sheet link"),
            ("image", "Flat-lay: daily productivity tools"),
            ("story", "Quiz: guess monthly revenue"),
            ("reel", "MVP build: no code tools tour"),
            ("carousel", "Tax write-off checklist‚Äîsave money"),
        ],
        "schedule": [
            "Monday: Idea validation reel",
            "Tuesday: Finance template carousel",
            "Wednesday: Cold email story",
            "Thursday: Live build session",
            "Friday: Launch checklist post",
            "Saturday: Testimonial feature",
            "Sunday: Goal reflection",
            "Week 2: KPI deep dive",
            "Week 2: Tax prep special",
            "Week 2: Content batching",
        ],
    },
}

# ------------------  FALLBACK PICKERS  ---------------------------------------
def pick_fallback_captions(niche: str, k: int = 10) -> List[str]:
    pool = NICHE_BANKS.get(niche, NICHE_BANKS["business"])["captions"]
    tag = niche.replace(" ", "")
    return [random.choice(pool).replace("{niche}", niche).replace("{tag}", tag) for _ in range(k)]

def pick_fallback_ideas(niche: str, k: int = 10) -> List[ContentIdea]:
    pool = NICHE_BANKS.get(niche, NICHE_BANKS["business"])["ideas"]
    tag = niche.replace(" ", "")
    # Cycle through pool to allow more than 10 items
    result = []
    for i in range(k):
        tp, idea = pool[i % len(pool)]
        result.append(ContentIdea(
            type=tp,
            idea=idea.replace("{niche}", niche).replace("{tag}", tag) + f" (Day {i+1})"
        ))
    return result

def pick_fallback_schedule_topics(niche: str, k: int = 10) -> List[str]:
    pool = NICHE_BANKS.get(niche, NICHE_BANKS["business"])["schedule"]
    tag = niche.replace(" ", "")
    return [random.choice(pool).replace("{niche}", niche).replace("{tag}", tag) for _ in range(k)]

# ------------------------------------------------------------------
#  ENSURE HELPERS
# ------------------------------------------------------------------
def _ensure_ideas(niche: str, ideas: List[ContentIdea], min_len: int = 1) -> List[ContentIdea]:
    if ideas and len(ideas) >= min_len:
        return ideas
    return pick_fallback_ideas(niche, min_len)

def _ensure_captions(niche: str, captions: List[Caption]) -> List[Caption]:
    if captions and len(captions) >= 5:
        return captions
    return [Caption(text=c) for c in pick_fallback_captions(niche, 10)]

# ------------------  GEMINI CLIENT  -------------------------------------------
class GeminiAI:
    def __init__(self, api_key: str):
        self.key = api_key.strip()
        self.url = "https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash-latest:generateContent"
        self.enabled = bool(self.key)
    async def generate(self, prompt: str, temp: float = .7, max_tokens: int = 2000) -> str:
        if not self.enabled: return ""
        payload = {"contents": [{"parts": [{"text": prompt}]}],
                   "generationConfig": {"temperature": temp, "maxOutputTokens": max_tokens}}
        try:
            async with aiohttp.ClientSession() as s:
                async with s.post(f"{self.url}?key={self.key}", json=payload, timeout=30) as r:
                    if r.status == 200:
                        cand = (await r.json()).get("candidates", [])
                        if cand: return cand[0]["content"]["parts"][0]["text"].strip()
        except Exception as e:
            print("‚ö†Ô∏è Gemini error:", str(e))
        return ""

# ------------------  WEB SCRAPER  ---------------------------------------------
class WebScraper:
    def __init__(self, serper_key: str): self.key = serper_key.strip()
    async def scrape(self, niche: str, kw: List[str]) -> List[Dict]:
        tags: List[Dict] = []
        if self.key:
            tags.extend(await self._serper(niche, kw))
        return tags
    async def _serper(self, niche: str, kw: List[str]) -> List[Dict]:
        q = f"top Instagram hashtags for {niche} {' '.join(kw[:2])} 2024"
        payload = {"q": q, "num_results": 20}
        hdr = {"X-API-KEY": self.key, "Content-Type": "application/json"}
        try:
            async with aiohttp.ClientSession() as s:
                async with s.post("https://google.serper.dev/search", json=payload, headers=hdr, timeout=20) as r:
                    if r.status == 200:
                        ser = await r.json()
                        tags = []
                        for item in ser.get("organic", []):
                            txt = f"{item.get('title','')} {item.get('snippet','')}"
                            for t in re.findall(r"#(\w+)", txt):
                                if 3 <= len(t) <= 25: tags.append({"tag": f"#{t.lower()}", "source": "serper"})
                        ab = ser.get("answerBox", {})
                        if ab:
                            for t in re.findall(r"#(\w+)", str(ab)):
                                if 3 <= len(t) <= 25: tags.append({"tag": f"#{t.lower()}", "source": "serper"})
                        for paa in ser.get("peopleAlsoAsk", []):
                            for t in re.findall(r"#(\w+)", str(paa)):
                                if 3 <= len(t) <= 25: tags.append({"tag": f"#{t.lower()}", "source": "serper"})
                        return tags[:30]
        except Exception as e:
            print("Serper scrape error:", str(e))
        return []

# ------------------  AGENT 1  ‚Äì  LIVE SCRAPE ‚Üí GEMINI  ------------------------
class HashtagScraperAgent:
    def __init__(self, ai: GeminiAI, scraper: WebScraper):
        self.ai = ai; self.scraper = scraper
    async def analyze(self, niche: str, kw: List[str]) -> List[Hashtag]:
        print("üîç Agent-1 ‚Äì live scrape + Gemini trending ‚Ä¶")
        raw = await self.scraper.scrape(niche, kw)
        if not raw:
            print("   ‚ö†Ô∏è  Serper empty ‚Äì asking Gemini for trending ‚Ä¶")
            gem_raw = await self.ai.generate(
                f"List 20 trending Instagram hashtags for {niche} keywords {','.join(kw)}. Return only hashtags, 1 per line.",
                temp=.8)
            for line in gem_raw.splitlines():
                t = line.strip()
                if t.startswith('#'): raw.append({"tag": t.lower(), "source": "gemini"})
        seen = set(); out = []
        for item in raw:
            tag = item["tag"].lower()
            if tag in seen or len(tag) < 3: continue
            seen.add(tag)
            posts = f"{random.randint(200,2000)}K" if len(tag) > 10 else f"{random.randint(5,20)}M+"
            out.append(Hashtag(tag=tag, posts=posts, competition="medium" if "M" in posts else "low",
                               relevance=round(random.uniform(.75, .95), 2), source=item.get("source", "mix")))
        if not out:
            print("   ‚ö†Ô∏è  ZERO hashtags ‚Äì returning fallback fitness list")
            fallback = ["#fitness", "#gym", "#workout", "#motivation", "#health", "#wellness", "#fitlife", "#training", "#exercise", "#strong"]
            for t in fallback:
                out.append(Hashtag(tag=t, posts=f"{random.randint(5,20)}M+", competition="medium",
                                   relevance=0.85, source="zero_fallback"))
        out.sort(key=lambda x: x.relevance, reverse=True)
        with open(OUTPUT_DIR / "hashtags.json", "w", encoding="utf8") as f:
            json.dump({"niche": niche, "date": datetime.now().isoformat(), "hashtags": [asdict(h) for h in out]}, f, indent=2)
        print(f"‚úÖ Agent-1 done ‚Äì {len(out)} hashtags")
        return out

# ------------------  AGENT 2  ‚Äì  RAW CONTENT IDEAS ONLY  ----------------------
class ContentPlannerAgent:
    def __init__(self, ai: GeminiAI): self.ai = ai
    async def plan(self, niche: str, hashtags: List[Hashtag], days: int) -> List[ContentIdea]:
        print("üé® Agent-2 ‚Äì generating raw content ideas ‚Ä¶")
        ideas: List[ContentIdea] = []
        used = set()
        prompt = (
            f"Give {days} different Instagram content IDEAS for the '{niche}' niche. "
            "Each idea must be unique (no repeated concepts). "
            "Output 1 idea per line in this exact format:\n"
            "TYPE: <reel|carousel|image|story>\n"
            "IDEA: <short 1-sentence creative prompt>\n\n"
            "Do NOT include timings, captions, or hashtags."
        )
        resp = await self.ai.generate(prompt, temp=0.9, max_tokens=2000)
        if resp:
            for block in resp.splitlines():
                block = block.strip()
                if block.startswith("TYPE:"):
                    post_type = block.replace("TYPE:", "").strip().lower()
                elif block.startswith("IDEA:"):
                    idea_txt = block.replace("IDEA:", "").strip()
                    if idea_txt and idea_txt not in used:
                        used.add(idea_txt)
                        ideas.append(ContentIdea(type=post_type, idea=idea_txt))
        ideas = _ensure_ideas(niche, ideas, days)
        with open(OUTPUT_DIR / "content_ideas.json", "w", encoding="utf8") as f:
            json.dump({"niche": niche, "date": datetime.now().isoformat(),
                       "ideas": [asdict(i) for i in ideas]}, f, indent=2)
        print(f"‚úÖ Agent-2 done ‚Äì {len(ideas)} fresh ideas")
        return ideas

# ------------------  AGENT 3  ‚Äì  SCHEDULER (1-POST-PER-DAY)  -----------------
class ScheduleManagerAgent:
    def organise(self, ideas: List[ContentIdea], days: int,
                 start: Optional[str] = None) -> List[ScheduleItem]:
        ideas = _ensure_ideas("business", ideas, days)  # guarantee *days* ideas
        ai_time = self._ask_gemini_times(ideas[0].type if ideas else "reel")[0]
        hour = int(ai_time.split(":")[0]) if ":" in ai_time else 18
        start_dt = datetime.strptime(start, "%Y-%m-%d") if start \
                   else datetime.now() + timedelta(days=1)
        items, pid = [], 1
        for d in range(days):                       # 1 row per calendar day
            dt = start_dt + timedelta(days=d, hours=hour)
            items.append(ScheduleItem(id=pid,
                                      content=ideas[d],
                                      scheduled_time=dt,
                                      status="scheduled"))
            pid += 1
        with open(OUTPUT_DIR / "schedule.json", "w", encoding="utf8") as f:
            json.dump({"date": datetime.now().isoformat(),
                       "schedule": [{"id": it.id,
                                     "content": asdict(it.content),
                                     "scheduled_time": it.scheduled_time.isoformat(),
                                     "status": it.status} for it in items]}, f, indent=2)
        return items

    def _ask_gemini_times(self, niche: str) -> List[str]:
        resp = asyncio.run(GeminiAI(GEMINI_API_KEY).generate(
            f"List 1 best posting time (HH:00) for Instagram {niche} niche.", temp=.7))
        times = [re.search(r"(\d{1,2}):00", line).group(1)+":00"
                 for line in resp.splitlines() if re.search(r"(\d{1,2}):00", line)]
        return times if times else ["18:00"]

# ------------------  AGENT 4  ‚Äì  CAPTION AGENT  ------------------------------
class CaptionAgent:
    def __init__(self, ai: GeminiAI): self.ai = ai
    async def generate_captions(self, niche: str, hashtags: List[Hashtag]) -> List[Caption]:
        print("üìù Agent-4 ‚Äì writing captions ‚Ä¶")
        tag_string = " ".join([h.tag for h in hashtags[:10]])
        prompt = (
            f"Write 20 different Instagram captions for the '{niche}' niche. "
            "Each caption must be unique, 1-2 sentences, include emojis, a CTA, and 5-7 hashtags. "
            "Output 1 caption per line only‚Äîno labels, no bullets."
        )
        resp = await self.ai.generate(prompt, temp=0.8, max_tokens=2000)
        captions = []
        if resp:
            for line in resp.splitlines():
                line = line.strip()
                if len(line) > 20:
                    captions.append(Caption(text=line))
        captions = _ensure_captions(niche, captions)
        with open(OUTPUT_DIR / "captions.json", "w", encoding="utf8") as f:
            json.dump({"niche": niche, "date": datetime.now().isoformat(),
                       "captions": [asdict(c) for c in captions]}, f, indent=2)
        print(f"‚úÖ Agent-4 done ‚Äì {len(captions)} captions")
        return captions

# ------------------  ORCHESTRATOR  -------------------------------------------
class Orchestrator:
    def __init__(self):
        self.ai   = GeminiAI(GEMINI_API_KEY)
        self.scraper = WebScraper(SERPER_API_KEY)
        self.a1 = HashtagScraperAgent(self.ai, self.scraper)
        self.a2 = ContentPlannerAgent(self.ai)
        self.a3 = ScheduleManagerAgent()
        self.a4 = CaptionAgent(self.ai)

    # ORDER: content ‚Üí hashtag ‚Üí caption ‚Üí schedule
    async def run_complete(self, niche: str, kw: List[str], days: int,
                         start: Optional[str] = None) -> Dict:
        ideas    = await self.a2.plan(niche, [], days)
        hashtags = await self.a1.analyze(niche, kw)
        captions = await self.a4.generate_captions(niche, hashtags)
        sched    = self.a3.organise(ideas, days, start)
        return {"ideas": ideas, "hashtags": hashtags,
                "captions": captions, "schedule": sched}

    async def run_agent(self, num: int, niche: str, kw: List[str], days: int = 7):
        if num == 1: return await self.a1.analyze(niche, kw)
        if num == 2:
            h = await self.a1.analyze(niche, kw); return await self.a2.plan(niche, h, days)
        if num == 3:
            h = await self.a1.analyze(niche, kw); c = await self.a2.plan(niche, h, days); return self.a3.organise(c, days)
        if num == 4:
            h = await self.a1.analyze(niche, kw); return await self.a4.generate_captions(niche, h)

# ------------------  GRADIO HANDLER  ------------------------------------------
orch = Orchestrator()

def fmt_hash(h):
    if not h: return "‚ùå No hashtags"
    rows = "| # | Hashtag | Posts | Competition | Relevance |\n|---|---------|-------|-------------|-----------|\n"
    for i, hashtag in enumerate(h[:20], 1):
        rows += f"| {i} | `{hashtag.tag}` | {hashtag.posts} | {hashtag.competition} | {hashtag.relevance} |\n"
    return "üè∑Ô∏è **Hashtags**\n\n" + rows

def fmt_ideas(p):
    if not p: return "‚ùå No content ideas"
    rows = "| # | Type | Idea |\n|---|------|------|\n"
    for i, idea in enumerate(p[:20], 1):
        rows += f"| {i} | **{idea.type.upper()}** | {idea.idea} |\n"
    return "üí° **Content Ideas**\n\n" + rows

def fmt_sched(s):
    if not s: return "‚ùå No schedule"
    rows = "| Day | Date / Time | Content Idea |\n|-----|-------------|--------------|\n"
    for it in s:
        t12 = it.scheduled_time.strftime("%a %d %b %I:%M %p")
        rows += f"| {it.id} | {t12} | {it.content.idea[:70]}‚Ä¶ |\n"
    return "üìÖ **Schedule**\n\n" + rows

def fmt_captions(cap):
    if not cap: return "‚ùå No captions"
    rows = "| # | Caption |\n|---|---------|\n"
    for i, c in enumerate(cap[:20], 1):
        rows += f"| {i} | {c.text} |\n"
    return "üìù **Captions**\n\n" + rows

def handle(niche, keywords, days, start_date, agent_choice):
    if not niche.strip():
        return ["‚ùå Please enter a niche"] + [""]*4
    kw_list  = [k.strip() for k in keywords.split(",")] if keywords else [niche]
    choice   = agent_choice.split(" ")[0]
    days     = int(days) if str(days).isdigit() else 7
    start    = start_date if start_date else None

    def _run(coro):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try: return loop.run_until_complete(coro)
        finally: loop.close()

    try:
        if choice == "‚ú®":
            res = _run(orch.run_complete(niche, kw_list, days, start))
            return ["‚úÖ Full pipeline finished ‚Äì files saved",
                    fmt_hash(res["hashtags"]),
                    fmt_ideas(res["ideas"]),
                    fmt_sched(res["schedule"]),
                    fmt_captions(res["captions"])]
        elif choice == "üé®":
            c = _run(orch.run_agent(2, niche, kw_list, days))
            return ["‚úÖ Agent-2 done", "", fmt_ideas(c), "", ""]
        elif choice == "üè∑Ô∏è":
            h = _run(orch.run_agent(1, niche, kw_list))
            return ["‚úÖ Agent-1 done", fmt_hash(h), "", "", ""]
        elif choice == "üìÖ":
            s = _run(orch.run_agent(3, niche, kw_list, days))
            return ["‚úÖ Agent-3 done", "", "", fmt_sched(s), ""]
        elif choice == "üìù":
            cap = _run(orch.run_agent(4, niche, kw_list))
            return ["‚úÖ Agent-4 done", "", "", "", fmt_captions(cap)]
        else:
            return ["‚ùå Unknown choice"] + [""]*4
    except Exception as e:
        return [f"‚ùå Error: {e}"] + [""]*4

# ------------------  GRADIO UI  -----------------------------------------------
with gr.Blocks(title="InstaGrowth AI ‚Äì 4-Agent System", theme=gr.themes.Soft()) as demo:
    gr.Markdown("# üöÄ InstaGrowth AI ‚Äì 4-Agent Instagram Growth System")
    gr.Markdown("**AI that Thinks Like a Marketer ‚Äî For Growth that Feels Organic**")

    with gr.Row():
        with gr.Column(scale=1):
            niche_in   = gr.Textbox(label="Niche", placeholder="e.g. fitness")
            kw_in      = gr.Textbox(label="Keywords (comma)", placeholder="gym, exercise")
            days_in    = gr.Slider(3, 10, value=7, step=1, label="Days (max 10)")
            start_in   = gr.Textbox(label="Start date YYYY-MM-DD (opt)")
            agent_dd   = gr.Dropdown(
                ["‚ú® Use all agents together",
                 "üé® Content ideas",
                 "üè∑Ô∏è Hashtags",
                 "üìù Captions",
                 "üìÖ Scheduling"],
                label="Agent choice", value="‚ú® Use all agents together")
            run_btn = gr.Button("Run", variant="primary", size="lg")

            with gr.Column(visible=False) as confirm_col:
                confirm_md = gr.Markdown("‚úÖ Full pipeline finished ‚Äì files saved")
                with gr.Row():
                    copy_btn  = gr.Button("üìã Copy to clipboard", size="sm")
                    down_btn  = gr.Button("üíæ Download ZIP", size="sm")

        with gr.Column(scale=2):
            output_md = gr.Markdown()

    zip_file = gr.File(label="download", visible=False)

    def _make_zip():
        zf = tempfile.NamedTemporaryFile(delete=False, suffix=".zip")
        with zipfile.ZipFile(zf, "w", zipfile.ZIP_DEFLATED) as z:
            for f in ["hashtags.json", "content_ideas.json", "schedule.json", "captions.json"]:
                p = OUTPUT_DIR / f
                if p.exists(): z.write(p, f)
        zf.close(); return zf.name

    def run_pipeline(niche, keywords, days, start_date, agent_choice):
        if not niche.strip():
            return [gr.update(visible=False), "‚ùå Please enter a niche", None]
        kw_list = [k.strip() for k in keywords.split(",")] if keywords else [niche]
        choice  = agent_choice.split(" ")[0]
        days    = int(days) if str(days).isdigit() else 7
        start   = start_date if start_date else None

        def _run(coro):
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try: return loop.run_until_complete(coro)
            finally: loop.close()

        try:
            if choice == "‚ú®":
                res = _run(orch.run_complete(niche, kw_list, days, start))
                txt = f"{fmt_hash(res['hashtags'])}\n\n{fmt_ideas(res['ideas'])}\n\n{fmt_sched(res['schedule'])}\n\n{fmt_captions(res['captions'])}"
                return [gr.update(visible=True), txt, _make_zip()]
            elif choice == "üé®":
                c = _run(orch.run_agent(2, niche, kw_list, days))
                return [gr.update(visible=True), fmt_ideas(c), None]
            elif choice == "üè∑Ô∏è":
                h = _run(orch.run_agent(1, niche, kw_list))
                return [gr.update(visible=True), fmt_hash(h), None]
            elif choice == "üìù":
                cap = _run(orch.run_agent(4, niche, kw_list))
                return [gr.update(visible=True), fmt_captions(cap), None]
            elif choice == "üìÖ":
                s = _run(orch.run_agent(3, niche, kw_list, days))
                return [gr.update(visible=True), fmt_sched(s), None]
            else:
                return [gr.update(visible=False), "‚ùå Unknown choice", None]
        except Exception as e:
            return [gr.update(visible=False), f"‚ùå Error: {e}", None]

    run_btn.click(run_pipeline, [niche_in, kw_in, days_in, start_in, agent_dd],
                  [confirm_col, output_md, zip_file])
    copy_btn.click(None, [], [], js="""
        () => navigator.clipboard.writeText(document.querySelector('.prose').innerText)""")
    down_btn.click(lambda f: f, inputs=[zip_file], outputs=[zip_file])

# ---------- KEEP CELL ALIVE ----------
demo.queue().launch(height=800, inline=True, share=True, prevent_thread_lock=True)
import threading, time
while True: time.sleep(1)